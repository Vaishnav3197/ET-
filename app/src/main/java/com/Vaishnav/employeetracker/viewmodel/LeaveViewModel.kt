package com.Vaishnav.employeetracker.viewmodel

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import com.Vaishnav.employeetracker.data.firebase.FirebaseLeaveRequest
import com.Vaishnav.employeetracker.data.firebase.FirebaseNotification
import com.Vaishnav.employeetracker.data.firebase.FirebaseManager
import com.Vaishnav.employeetracker.utils.DateTimeHelper
import kotlinx.coroutines.flow.*

class LeaveViewModel(application: Application) : AndroidViewModel(application) {
    private val leaveRepo = FirebaseManager.leaveRepository
    private val employeeRepo = FirebaseManager.employeeRepository
    private val notificationRepo = FirebaseManager.notificationRepository
    
    fun getMyLeaves(employeeId: String): Flow<List<FirebaseLeaveRequest>> {
        return leaveRepo.getEmployeeLeaveRequests(employeeId)
    }
    
    fun getLeavesByStatus(employeeId: String, status: String): Flow<List<FirebaseLeaveRequest>> {
        return flow {
            leaveRepo.getAllLeaveRequests().collect { all ->
                emit(all.filter { it.status == status })
            }
        }
    }
    
    fun getPendingLeaves(adminId: String? = null): Flow<List<FirebaseLeaveRequest>> {
        return if (adminId != null) {
            // Filter by admin's employees with continuous observation
            leaveRepo.getPendingLeaveRequests().map { allPending ->
                employeeRepo.getEmployeesByAdminId(adminId).first().let { employees ->
                    val employeeIds = employees.map { it.id }.toSet()
                    allPending.filter { employeeIds.contains(it.employeeId) }
                }
            }
        } else {
            // Show all pending leaves
            leaveRepo.getPendingLeaveRequests()
        }
    }
    
    suspend fun getPendingCount(adminId: String? = null): Int {
        return if (adminId != null) {
            // Count only admin's employees
            val employees = employeeRepo.getEmployeesByAdminId(adminId).first()
            val employeeIds = employees.map { it.id }.toSet()
            leaveRepo.getAllLeaveRequests().first().count { 
                it.status == "Pending" && employeeIds.contains(it.employeeId) 
            }
        } else {
            // Count all pending leaves
            leaveRepo.getAllLeaveRequests().first().count { it.status == "Pending" }
        }
    }
    
    suspend fun applyLeave(
        employeeId: String,
        leaveType: String,
        startDate: Long,
        endDate: Long,
        reason: String
    ): Result<String> {
        return try {
            // Validate dates
            if (startDate > endDate) {
                return Result.failure(Exception("Start date cannot be after end date"))
            }
            
            if (startDate < DateTimeHelper.getStartOfDay(DateTimeHelper.getCurrentTimestamp())) {
                return Result.failure(Exception("Cannot apply for past dates"))
            }
            
            // Calculate working days
            val workingDays = DateTimeHelper.getWorkingDaysBetween(startDate, endDate)
            if (workingDays < 1) {
                return Result.failure(Exception("Leave must be at least 1 working day"))
            }
            
            val leaveRequest = FirebaseLeaveRequest(
                id = "", // Auto-generated by Firestore
                employeeId = employeeId,
                leaveType = leaveType,
                startDate = startDate,
                endDate = endDate,
                reason = reason,
                status = "Pending",
                requestDate = null, // ServerTimestamp will be set by Firestore
                approvedByAdminId = null,
                approvalDate = null,
                adminRemarks = null
            )
            
            leaveRepo.addLeaveRequest(leaveRequest)
            
            Result.success("Leave request submitted successfully")
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun approveLeave(leaveId: String, adminId: String, remarks: String = ""): Result<String> {
        return try {
            val allLeaves = leaveRepo.getAllLeaveRequests().first()
            val leave = allLeaves.find { it.id == leaveId }
            if (leave == null) {
                return Result.failure(Exception("Leave request not found"))
            }
            
            leaveRepo.updateLeaveStatus(leaveId, "Approved", adminId, remarks)
            
            // Send notification to employee
            val notification = FirebaseNotification(
                id = "",
                userId = leave.employeeId,
                title = "Leave Approved",
                message = "Your leave request from ${DateTimeHelper.formatDate(leave.startDate)} to ${DateTimeHelper.formatDate(leave.endDate)} has been approved",
                type = "Leave",
                relatedId = leaveId,
                timestamp = null,
                isRead = false
            )
            notificationRepo.addNotification(notification)
            
            Result.success("Leave approved successfully")
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun rejectLeave(leaveId: String, adminId: String, remarks: String): Result<String> {
        return try {
            val allLeaves = leaveRepo.getAllLeaveRequests().first()
            val leave = allLeaves.find { it.id == leaveId }
            if (leave == null) {
                return Result.failure(Exception("Leave request not found"))
            }
            
            if (remarks.isBlank()) {
                return Result.failure(Exception("Please provide a reason for rejection"))
            }
            
            leaveRepo.updateLeaveStatus(leaveId, "Rejected", adminId, remarks)
            
            // Send notification
            val notification = FirebaseNotification(
                id = "",
                userId = leave.employeeId,
                title = "Leave Rejected",
                message = "Your leave request has been rejected. Reason: $remarks",
                type = "Leave",
                relatedId = leaveId,
                timestamp = null,
                isRead = false
            )
            notificationRepo.addNotification(notification)
            
            Result.success("Leave rejected")
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    data class LeaveStats(
        val totalLeaves: Int,
        val approvedLeaves: Int,
        val pendingLeaves: Int,
        val rejectedLeaves: Int
    )
}
